#!/bin/python3

import argparse
import sys, os
from datetime import datetime

def getOptions( args = sys.argv[1:] ):
    parser = argparse.ArgumentParser( description = "Parses commands." )

    msgInp = 'Input file.'
    msgAdd = 'File to be added.'
    msgApp = 'Message to be appended to the file.'
    msgMod = 'Modify the nth comment of a file.'
    msgDel = 'Delete the nth comment of a file or the lines containing string.'
    msgRem = 'Remove all the contents related to a file'
    msgAll = 'Show all the files registered'
    msgDat = 'Add date of creation at the beginning of the file'
    msgGlo = 'Use the global version of book instead of local'

    parser.add_argument( "-i", "--input", help = msgInp )
    parser.add_argument( "-A", "--add", help = msgAdd )
    parser.add_argument( "-a", "--append", help = msgApp )
    parser.add_argument( "-m", "--modify", help = msgMod )
    parser.add_argument( "-d", "--delete", help = msgDel )
    parser.add_argument( "-r", "--remove", help = msgRem, action = 'store_true')
    parser.add_argument( "-S", "--show_all", help = msgAll, action = 'store_true' )
    parser.add_argument( "-t", "--time", help = msgDat, action = 'store_true' )
    parser.add_argument( "-g", "--glob_file", help = msgDat, action = 'store_true' )

    parser.set_defaults( remove =  False )
    parser.set_defaults( show_all = False )
    parser.set_defaults( time = False )
    parser.set_defaults( glob_file = False )

    options = parser.parse_args( args )
    return options

class TermColors:
    BOLD = '\033[1m'
    RED  = '\033[91m'
    WARN = '\033[93m'
    ENDL = '\033[0m'
    UNDL = '\033[4m'

SEPARATOR = '--//--'

class Book:

    def __init__( self, bookf_path, chapter = 'NULL' ):
        """
        Constructor of the class. It stores the data inside fileToSave into a 
        dictionary to be manipulated.
        Arguments:
            self ( Book object ):
            bookf_path ( string ):
                String containing the path and name of the book file in which we
                will store the data.
            chapter ( string ):
                String containing the chapter inside book we would like to 
                manipulate.
        Returns:
        """
         
        self.bookf = bookf_path
        self.chapter = chapter
        self.book_contents = {}
       
        try: # If the book file exists
            with open( self.bookf ) as fbuf:
                contents = fbuf.readlines()
                contents = [ x.strip() for x in contents ]
                auxHold = []
                for line in contents:
                    auxHold.append( line )
                    if line == SEPARATOR:
                        self.book_contents[auxHold[0]] = auxHold[1:-1]
                        auxHold = []
        except IOError: # If the book file does not exist
            assert( self.chapter != 'NULL' )
            with open( self.bookf, 'w' ) as fbuf:
                fbuf.write( '{}\n'.format( self.chapter ) )
                fbuf.write( SEPARATOR )

    def __checkEx( self ):
        """
        Raise an error if the chapter is not found in the book file.
        """
        if self.chapter not in self.book_contents:
            raise ValueError( 'ERROR: Chapter does not exist in book file' )

    def flsData( self ):
        """ 
        Method to overwrite the manipulated data of the session inside the
        book file
        """
        with open( self.bookf, 'w' ) as fbuf:
            for chapter in self.book_contents.keys():
                fbuf.write( chapter + '\n' )
                for content in self.book_contents[chapter]:
                    fbuf.write( content + '\n' )
                fbuf.write( SEPARATOR + '\n' )

    def finData( self ):
        """
        Show the contents inside a given chapter.
        """
        # Find the data to print the content out in the command line
        self.__checkEx()    # Check existence of the file

        # Print the chapter name
        print( TermColors.RED + TermColors.BOLD + self.chapter + TermColors.ENDL )

        # Print the contents of the chapter
        for index, content in enumerate( self.book_contents[self.chapter] ):
            if index != len( self.book_contents[self.chapter] ):
                print( str(index) + ': ' + TermColors.BOLD + content + \
                       TermColors.ENDL )

    def shwData( self ):
        """
        Iterate through all the chapters in the file to retrieve their contents
        """
        # Show all the data registered inside book
        
        for chapter in self.book_contents.keys():
            # Print the chapters
            self.chapter = chapter
            self.finData()

    def addFile( self ):
        """ 
        Add a new file without contents inside.
        """
        try:
            assert( self.chapter not in self.book_contents.keys() )
            self.book_contents[self.chapter] = [ SEPARATOR ]
        except AssertionError:
            raise AssertionError( 'ERROR: The chapter is currently inside book' )

    def appData( self, comment, position = None ):
        """
        Append content to the nth position of the chapter
        """
        if position is None:
            position = len( self.book_contents[self.chapter] )
        self.__checkEx()    # Check existence of chapter
        self.book_contents[self.chapter].insert( position, comment )
        
    def mdfData( self, position ):
        """
        Modify the nth comment inside a chapter. Note the contents are indexed
        using an array from 0 to N -1.
        """

        self.__checkEx()  # Check existence of the file
        try:
            assert( isinstance( position, int ) )
            assert( position <= len( self.book_contents[self.chapter] ) )
            print( TermColors.WARN + TermColors.BOLD + \
                   self.book_contents[self.chapter][position] + TermColors.ENDL )
            new_line = input( 'Enter your modified line: ' )
            self.book_contents[self.chapter].insert( position, new_line )
        except AssertionError:
            raise AssertionError( 'ERROR: Position has to be an integer and ' + 
                    'less or equal than the amount of contents in chapter' )

    def elmData( self, line ):
        """
        Eliminate content of a chapter depending of type of argument. If the 
        argument is a string, then we eliminate all contents that contain
        that string in a chapter. If the argument is an integer, then we 
        eliminate the line corresponding to that integer'
        """

        self.__checkEx()    # Check existence of the chapter
        assert( isinstance( line, int ) or isinstance( line, str ) )

        if isinstance( line, int ): # Delete the nth content of chapter
            del self.book_contents[self.chapter][line]
        else: # Delete contents that contain that string
            hold_list = [ ( index, match ) for index, match in \
                          enumerate( self.book_contents[self.chapter] ) \
                          if line in match ]
            if hold_list is not None:
                print( TermColors.RED + 'These are the matched lines' )
                for match in hold_list:
                    print( match[1] )
                checkDelete = int( 
                        raw_input( 'Are you sure you want to delete them [Y/n]: ')

                

    def delFile( self ):
        # Eliminate the data corresponding to a file
        self.checkEx()
        for i in range( len( self.holdData ) ):
            if self.nameFile in self.holdData[i]:
                self.holdData.pop( i )

if __name__ == '__main__':
    
    fileToSave = '.book'
    book = Book( fileToSave, 'TRIAL' )
    # book.finData()
    book.shwData()
    # book.mdfData( 1 )
    # book.flsData()
    book.elmData( 'comentario' )

    # if getOptions().glob_file:
    #     DOT_CACHE = '{}/.cache/book'.format( os.environ['HOME'] )
    #     # File to save the data
    #     if not os.path.exists( DOT_CACHE ):
    #         os.makedirs( DOT_CACHE )

    #     fileToSave = '{}/.book'.format( DOT_CACHE )
    # else:
    #     fileToSave = '.book'

    # if getOptions().show_all:
    #     book = Book( fileToSave )
    #     book.shwData()
    # else:

    #     # Add a file if it does not exist
    #     if getOptions().add is not None:
    #         nameFile = getOptions().add
    #         book = Book( fileToSave, nameFile )
    #         book.addFile()

    #     else:
    #         # Generate the file name to be used
    #         if getOptions().input is not None:
    #             nameFile = getOptions().input
    #         else:
    #             nameFile = input( "Enter name of file: " )

    #         # Create a Book object that will manage the IO
    #         book = Book( fileToSave, nameFile )

    #         # Append something to the file
    #         if getOptions().append is not None:
    #             if getOptions().time:
    #                 date = datetime.now().strftime( '%Y-%m-%d %H:%M' )
    #                 book.appData( getOptions().append, date )
    #             else:
    #                 book.appData( getOptions().append )

    #         # Modify the line of a comment
    #         if getOptions().modify is not None:
    #             book.mdfData( getOptions().modify )

    #         if getOptions().delete is not None:
    #             book.elmData( getOptions().delete )


    #         if getOptions().show_all:
    #             book.shwData()

    #         # Show the data contained in the file
    #         book.finData()

    #         if getOptions().remove:
    #             book.delFile()

    #     # Flush everything out
    #     book.flsData()



