#!/bin/python3

import argparse
import sys, os
from time import gmtime, strftime
import regex as re

SEPARATOR = '--//--'

def getOptions( args = sys.argv[1:] ):
    parser = argparse.ArgumentParser( description = "Parses commands." )

    msgInp = 'Chapter to work on.'
    msgAdd = 'Add a new empty chapter to the file.'
    msgApp = 'Add a new comment to the current chapter.'
    msgMod = 'Manipulate the nth comment of a chapter.'
    msgDel = 'Delete the nth comment of the chapter or all the comments ' + \
             'containing the string provided'
    msgRem = 'Remove a chapter from the book.'
    msgAll = 'Show all the contents inside book file.'
    msgDat = 'Show the date of creation of the comments.'
    msgGlo = 'Use the global version of book instead of local'

    parser.add_argument( "-i", "--input", help = msgInp )
    parser.add_argument( "-A", "--add", help = msgAdd )
    parser.add_argument( "-a", "--append", help = msgApp )
    parser.add_argument( "-m", "--modify", help = msgMod )
    parser.add_argument( "-d", "--delete", help = msgDel )
    parser.add_argument( "-r", "--remove", help = msgRem, action = 'store_true')
    parser.add_argument( "-S", "--show_all", help = msgAll, action = 'store_true' )
    parser.add_argument( "-t", "--time", help = msgDat, action = 'store_true' )
    parser.add_argument( "-g", "--glob_file", help = msgDat, action = 'store_true' )

    parser.set_defaults( remove =  False )
    parser.set_defaults( show_all = False )
    parser.set_defaults( time = False )
    parser.set_defaults( glob_file = False )

    options = parser.parse_args( args )
    return options

class TermColors:
    BOLD = '\033[1m'
    RED  = '\033[91m'
    WARN = '\033[93m'
    ENDL = '\033[0m'
    UNDL = '\033[4m'

months = {
        '01': [ 'jan', 'january', '01', '1', 'ene', 'enero' ],
        '02': [ 'feb', 'february', '02', '2', 'febrero' ],
        '03': [ 'mar', 'march', '03', '3', 'marzo' ],
        '04': [ 'apr', 'april', '04', '4', 'abr', 'abril' ],
        '05': [ 'may', '05', '5', 'mayo' ], 
        '06': [ 'jun', 'june', '06', '6', 'junio' ],
        '07': [ 'jul', 'july', '07', '7', 'julio' ],
        '08': [ 'aug', 'august', '08', '8', 'ago', 'agosto' ],
        '09': [ 'sept', 'september', '09', '9', 'septiembre' ],
        '10': [ 'oct', 'october', '10', 'septiembre' ],
        '11': [ 'nov', 'november', '11', 'noviembre' ],
        '12': [ 'dec', 'december', '12', 'dic', 'diciembre' ]
    }

class Book:

    def __init__( self, bookf_path, chapter = 'NULL' ):
        """
        Constructor of the class. It stores the data inside fileToSave into a 
        dictionary to be manipulated.
        Arguments:
            self ( Book object ):
            bookf_path ( string ):
                String containing the path and name of the book file in which we
                will store the data.
            chapter ( string ):
                String containing the chapter inside book we would like to 
                manipulate.
        Returns:
        """
         
        self.bookf = bookf_path
        self.chapter = chapter

        self.book_contents = {}
        self.book_dates = {}
       
        try: # If the book file exists
            with open( self.bookf ) as fbuf:
                contents = fbuf.readlines()
                contents = [ x.strip() for x in contents ]
                hold_dates, hold_comments = [], []
                for line in contents:
                    line = line.split( '#' )
                    if len( line ) == 2: # Take care of comments
                        hold_dates.append( line[0] ), hold_comments.append( line[1] )
                    else: # Take care of Chapter and Separator
                        hold_comments.append( line[0] )
                    if line[0] == SEPARATOR:
                        self.book_contents[hold_comments[0]] = hold_comments[1:-1]
                        self.book_dates[hold_comments[0]] = hold_dates
                        hold_dates, hold_comments = [], [] 

        except IOError: # If the book file does not exist
            assert( self.chapter != 'NULL' )
            with open( self.bookf, 'w' ) as fbuf:
                fbuf.write( '{}\n'.format( self.chapter ) )
                fbuf.write( SEPARATOR )

    def __checkEx( self ):
        """
        Raise an error if the chapter is not found in the book file.
        """
        if self.chapter not in self.book_contents:
            raise ValueError( 'ERROR: Chapter does not exist in book file' )

    def flsData( self ):
        """ 
        Method to overwrite the manipulated data of the session inside the
        book file
        """
        with open( self.bookf, 'w' ) as fbuf:
            for chapter in self.book_contents.keys():
                fbuf.write( chapter + '\n' )
                for index, content in enumerate( self.book_contents[chapter] ):
                    fbuf.write( self.book_dates[chapter][index] + '#' + \
                                content + '\n' )
                fbuf.write( SEPARATOR + '\n' )

    def finData( self, aux_chapter = None, print_date = False ):
        """
        Show the contents inside a given chapter.
        """
        # Find the data to print the content out in the command line
        if aux_chapter is None:
            aux_chapter = self.chapter
            self.__checkEx()
        
        # Print the chapter name
        print( TermColors.RED + TermColors.BOLD + aux_chapter + TermColors.ENDL )

        for index, content in enumerate( self.book_contents[aux_chapter] ):
            if print_date:
                content = self.book_dates[aux_chapter][index] + ': ' + content
            # Print the contents of the chapter
            if index != len( self.book_contents[aux_chapter] ):
                print( TermColors.BOLD + content + TermColors.ENDL )

    def shwData( self, print_date = False ):
        """
        Iterate through all the chapters in the file to retrieve their contents
        """
        # Show all the data registered inside book
        for chapter in self.book_contents.keys():
            # Print the chapters
            self.finData( chapter, print_date )

    def addFile( self ):
        """ 
        Add a new file without contents inside.
        """
        try:
            assert( self.chapter not in self.book_contents.keys() )
            self.book_contents[self.chapter] = [ SEPARATOR ]
        except AssertionError:
            raise AssertionError( 'ERROR: The chapter is currently inside book' )

    def appData( self, comment, position = None ):
        """
        Append content to the nth position of the chapter. The date of creation is
        always appended at the beginning, it is used for filtering.
        """
        if position is None:
            position = len( self.book_contents[self.chapter] )
        self.__checkEx()    # Check existence of chapter
        date = strftime( "%d-%m-%Y", gmtime() )
        comment = date + ': ' + comment
        self.book_contents[self.chapter].insert( position, comment )
        
    def mdfData( self, position ):
        """
        Modify the nth comment inside a chapter. Note the contents are indexed
        using an array from 0 to N -1.
        """

        self.__checkEx()  # Check existence of the file
        try:
            assert( isinstance( position, int ) )
            assert( position <= len( self.book_contents[self.chapter] ) )
            print( TermColors.WARN + TermColors.BOLD + \
                   self.book_contents[self.chapter][position] + TermColors.ENDL )
            new_line = input( 'Enter your modified line: ' )
            date = strftime( "%d-%m-%Y", gmtime() )
            del self.book_contents[self.chapter][position]
            del self.book_dates[self.chapter][position]
            self.book_contents[self.chapter].insert( position, new_line )
            self.book_dates[self.chapter].insert( position, date )
        except AssertionError:
            raise AssertionError( 'ERROR: Position has to be an integer and ' + 
                    'less or equal than the amount of contents in chapter' )

    def elmData( self, line ):
        """
        Eliminate content of a chapter depending of type of argument. If the 
        argument is a string, then we eliminate all contents that contain
        that string in a chapter. If the argument is an integer, then we 
        eliminate the line corresponding to that integer'
        """

        self.__checkEx()    # Check existence of the chapter
        assert( isinstance( line, int ) or isinstance( line, str ) )
        yes = set( ['yes', 'y', 'ye', ''] )

        if isinstance( line, int ): # Delete the nth content of chapter
            del self.book_contents[self.chapter][line]
        else: # Delete contents that contain that string
            hold_list = [ ( index, match ) for index, match in \
                          enumerate( self.book_contents[self.chapter] ) \
                          if line in match ]
            if hold_list is not None:
                print( TermColors.RED + 'These are the matched lines' + \
                       TermColors.ENDL )
                for match in hold_list:
                    print( match[0], ': ', match[1] )
                check_del = input( 'Are you sure you want to delete them [Y/n]: ')
                check_del = check_del.lower()
                if check_del in yes:
                    # Delete the stuff
                    matches = set( [ match for ( ind, match ) in hold_list ] )
                    set_chapter = set( self.book_contents[self.chapter] )
                    self.book_contents[self.chapter] = \
                            list( set_chapter - matches )
                else:
                    print( 'That does not looks like a yes' )
            else:
                print( 'There are not matched lines in the current chapter' )

    def delFile( self ):
        """
        Eliminate all contents inside a chapter, including the chapter itself
        """
        self.__checkEx() # Check for existence of chapter
        del self.book_contents[self.chapter]
    
    def filtData( self, QUERY ):
        """
        Function to filter data from a chapter based on a query
        """
         
        check = re.match( "[mydDYM]\\d+(-[mydDYM]\\d+-[mydDYM]\\d+)?", QUERY )

        # Make this better with an ERROR message
        try:
            assert ( check is not None )
        except AssertionError:
            error = "ERROR: Query has to fulfill the following condition '[dD][0-9]+-[mM][a-zA-Z0-9]+-[yY][0-9]+"
            raise AssertionError( error )

        search_month = re.search( r'.*[Mm]([a-zA-Z0-9]+)*', QUERY ) 
        search_year = re.search( r'.*[Yy]([0-9]+)*', QUERY ) 
        search_day = re.search( r'.*[Dy]([0-9]+)*', QUERY ) 
        
        # Initial values of the matches
        get_month, get_year, get_day = '*', '*', '*'

        # Check for values on the array
        if search_month is not None:
            get_month = search_month.group(1)
            for key, month in months.items():
                if get_month.lower() in month:
                    extract_key = str(key)
            get_month = extract_key 

        if search_year is not None:
            get_year = search_year.group(1)

        if search_day is not None:
            get_day = search_day.group(1)
            if int(get_day) < 10:
                get_day = '0' + get_day

        # Look for matches inside chapter
        match_dates = []
        for index, date in enumerate( self.book_dates[self.chapter] ):
            if get_day == '*':
                match = re.match( r'.*-%s-%s*' %( get_month, get_year ), date )
            else:
                match = re.match( r'%s-%s-%s*' %( get_day, get_month, get_year ), \
                                  date )
            if match is not None:
                match_dates.append( index )

        print( TermColors.RED + TermColors.BOLD + self.chapter + TermColors.ENDL )
        for index in match_dates:
            content = self.book_dates[self.chapter][int(index)] + ': ' + \
                      self.book_contents[self.chapter][int(index)]
            print( TermColors.BOLD + content + TermColors.ENDL )

if __name__ == '__main__':
    
    fileToSave = '.book'
    book = Book( fileToSave, 'TRIAL' )
    # book.mdfData( 0 ) 
    # book.shwData( print_date = True )
    book.filtData( 'Y2020-M1' )

    # if getOptions().glob_file:
    #     DOT_CACHE = '{}/.cache/book'.format( os.environ['HOME'] )
    #     # File to save the data
    #     if not os.path.exists( DOT_CACHE ):
    #         os.makedirs( DOT_CACHE )

    #     fileToSave = '{}/.book'.format( DOT_CACHE )
    # else:
    #     fileToSave = '.book'

    # if getOptions().show_all:
    #     book = Book( fileToSave )
    #     book.shwData()
    # else:

    #     # Add a file if it does not exist
    #     if getOptions().add is not None:
    #         nameFile = getOptions().add
    #         book = Book( fileToSave, nameFile )
    #         book.addFile()

    #     else:
    #         # Generate the file name to be used
    #         if getOptions().input is not None:
    #             nameFile = getOptions().input
    #         else:
    #             nameFile = input( "Enter name of file: " )

    #         # Create a Book object that will manage the IO
    #         book = Book( fileToSave, nameFile )

    #         # Append something to the file
    #         if getOptions().append is not None:
    #             if getOptions().time:
    #                 date = datetime.now().strftime( '%Y-%m-%d %H:%M' )
    #                 book.appData( getOptions().append, date )
    #             else:
    #                 book.appData( getOptions().append )

    #         # Modify the line of a comment
    #         if getOptions().modify is not None:
    #             book.mdfData( getOptions().modify )

    #         if getOptions().delete is not None:
    #             book.elmData( getOptions().delete )


    #         if getOptions().show_all:
    #             book.shwData()

    #         # Show the data contained in the file
    #         book.finData()

    #         if getOptions().remove:
    #             book.delFile()

    #     # Flush everything out
    #     book.flsData()



